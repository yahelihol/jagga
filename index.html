<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Foreign Language Typing Trainer</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      padding: 2rem;
      background: #f9f9fb;
      color: #222;
      max-width: 900px;
      margin: auto;
    }

    h1 {
      font-size: 2rem;
      margin-bottom: 1rem;
    }

    .stream-wrapper {
      display: flex;
      gap: 2rem;
      overflow-x: auto;
      padding-bottom: 1rem;
      margin-bottom: 1rem;
      border-bottom: 2px solid #ddd;
      white-space: nowrap;
      scroll-behavior: smooth;
      scroll-snap-type: x mandatory;
    }

    .word-pair {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: max-content;
      opacity: 0;
      transform: translateX(30px);
      transition: all 0.4s ease;
      scroll-snap-align: center;
    }

    .word-pair.visible {
      opacity: 1;
      transform: translateX(0);
    }

    .word-block {
      display: flex;
      gap: 0.25rem;
      font-size: 1.8rem;
      line-height: 2.5rem;
    }

    .word-block.translation {
      font-size: 1rem;
      color: #666;
    }

    .letter {
      padding: 0 0.1rem;
    }

    .current {
      background-color: #ffd54f;
      border-radius: 4px;
    }

    .current-translation {
      font-weight: bold;
      color: #222;
    }

    .score-display {
      font-size: 1rem;
      margin-bottom: 0.5rem;
      color: #333;
    }

    .input-field {
      font-size: 1.5rem;
      padding: 0.75rem;
      background: white;
      border: 1px solid #ccc;
      width: 100%;
      margin-bottom: 1rem;
    }

    .strike {
      text-decoration: line-through;
      color: #e53935;
    }

    .correct {
      color: #43a047;
    }

    .status {
      font-style: italic;
      color: #555;
      margin-bottom: 1rem;
    }

    button {
      background-color: #2196f3;
      color: white;
      border: none;
      padding: 0.6rem 1.2rem;
      font-size: 1rem;
      border-radius: 4px;
      cursor: pointer;
    }

    button:hover {
      background-color: #1976d2;
    }

    @keyframes slam {
      0% {
        opacity: 0;
        transform: translateY(-15px) rotate(-20deg) scale(1.3);
      }
      40% {
        opacity: 1;
        transform: translateY(5px) rotate(10deg) scale(0.95);
      }
      70% {
        transform: translateY(-3px) rotate(-5deg) scale(1.05);
      }
      100% {
        opacity: 1;
        transform: translateY(0) rotate(0deg) scale(1);
      }
    }

    .slam {
      animation: slam 0.3s ease forwards;
      display: inline-block;
    }

    #typed-output {
      font-size: 1.3rem;
      margin-bottom: 1rem;
      white-space: nowrap;
      overflow-x: auto;
    }

    #progress-bar {
      height: 6px;
      background: #ddd;
    }

    #progress-fill {
      height: 100%;
      width: 0;
      background: #4caf50;
    }

    @media (max-width: 600px) {
      body {
        padding: 1rem;
        font-size: 1rem;
      }

      .word-block {
        font-size: 1.5rem;
      }

      .input-field {
        font-size: 1.2rem;
        padding: 0.5rem;
      }

      button {
        font-size: 1rem;
        padding: 0.5rem 1rem;
      }
    }
  </style>
</head>
<body>
  <h1>Foreign Reading Practice</h1>

  <div class="stream-wrapper" id="stream-wrapper"></div>

  <div class="score-display" id="score-display"></div>

  <div id="typed-output"></div>
  <input id="input-field" class="input-field" type="text" autocomplete="off" autocorrect="off" autocapitalize="off" />
  <div class="status" id="status-message"></div>
  <div id="progress-bar">
    <div id="progress-fill"></div>
  </div>
  <div style="height: 6px;"></div>
  <button id="restart-button">Restart</button>

  <script>
    const foreignWords = [
      { word: "감사합니다", phonetic: ["gam", "sa", "hab", "ni", "da"], translation: "thank you" },
      { word: "안녕하세요", phonetic: ["an", "nyeong", "ha", "se", "yo"], translation: "hello" },
      { word: "사랑해요", phonetic: ["sa", "rang", "hae", "yo"], translation: "I love you" },
      { word: "미안합니다", phonetic: ["mi", "an", "ham", "ni", "da"], translation: "I'm sorry" },
      { word: "괜찮아요", phonetic: ["gwaen", "chan", "a", "yo"], translation: "It's okay" },
      { word: "네", phonetic: ["ne"], translation: "yes" },
      { word: "아니요", phonetic: ["a", "ni", "yo"], translation: "no" },
      { word: "주세요", phonetic: ["ju", "se", "yo"], translation: "please give me" },
      { word: "이해해요", phonetic: ["i", "hae", "hae", "yo"], translation: "I understand" },
      { word: "몰라요", phonetic: ["mol", "la", "yo"], translation: "I don’t know" }
    ];

    let totalCorrect = 0;
    let totalMistakes = 0;

    let currentWordIndex = 0;
    let currentLetterIndex = 0;
    let inputHistory = [];
    let currentInputBuffer = "";
    const wordSpans = [];

    const streamWrapper = document.getElementById("stream-wrapper");
    const inputField = document.getElementById("input-field");
    const statusMessage = document.getElementById("status-message");
    const progressBar = document.getElementById("progress-fill");
    const restartButton = document.getElementById("restart-button");
    const typedOutput = document.getElementById("typed-output");

    function renderAllWords() {
      streamWrapper.innerHTML = "";
      wordSpans.length = 0;
      foreignWords.forEach(createWordBlock);
      streamWrapper.scrollLeft = 0;
    }

    function centerCurrentWord() {
      const container = streamWrapper;
      if (!wordSpans[currentWordIndex]) return;

      const wordPairDiv = container.children[currentWordIndex];
      if (!wordPairDiv) return;

      const containerRect = container.getBoundingClientRect();
      const wordRect = wordPairDiv.getBoundingClientRect();
      const offset = wordRect.left - containerRect.left - (containerRect.width / 2) + (wordRect.width / 2);
      container.scrollBy({ left: offset, behavior: "smooth" });
    }

    function createWordBlock(word) {
      const spanGroup = [];
      const wordPair = document.createElement("div");
      wordPair.classList.add("word-pair");

      const wordBlock = document.createElement("div");
      wordBlock.classList.add("word-block");
      wordBlock.title = word.phonetic.join("-");

      [...word.word].forEach(letter => {
        const span = document.createElement("span");
        span.classList.add("letter");
        span.textContent = letter;
        wordBlock.appendChild(span);
        spanGroup.push(span);
      });

      const translation = document.createElement("div");
      translation.textContent = word.translation;
      translation.classList.add("word-block", "translation");

      wordPair.appendChild(wordBlock);
      wordPair.appendChild(translation);

      streamWrapper.appendChild(wordPair);
      setTimeout(() => wordPair.classList.add("visible"), 20);

      wordSpans.push({ foreign: spanGroup, translation });
    }

    function highlightCurrentLetter() {
      wordSpans.forEach((spanGroup, wIndex) => {
        spanGroup.foreign.forEach((span, lIndex) => {
          span.classList.toggle("current", wIndex === currentWordIndex && lIndex === currentLetterIndex);
        });
        spanGroup.translation.classList.toggle("current-translation", wIndex === currentWordIndex);
      });
    }

    function renderInput() {
      typedOutput.innerHTML = "";
      inputHistory.forEach(entry => {
        const span = document.createElement("span");
        span.textContent = entry.char;
        span.classList.add(entry.status === "correct" ? "correct" : "strike");
        if (!entry.animated) {
          span.classList.add("slam");
          entry.animated = true;
          span.addEventListener("animationend", () => span.classList.remove("slam"), { once: true });
        }
        typedOutput.appendChild(span);
      });

      if (currentInputBuffer) {
        const span = document.createElement("span");
        span.textContent = currentInputBuffer;
        span.classList.add("slam");
        span.addEventListener("animationend", () => span.classList.remove("slam"), { once: true });
        typedOutput.appendChild(span);
      }
    }

    function loadWord(index) {
      if (index >= foreignWords.length) return;
      currentWordIndex = index;
      currentLetterIndex = 0;
      inputHistory = [];
      currentInputBuffer = "";
      renderInput();
      highlightCurrentLetter();
      inputField.value = "";
      inputField.focus();
      statusMessage.textContent = `Word ${index + 1} of ${foreignWords.length}`;
      progressBar.style.width = `${(currentWordIndex / foreignWords.length) * 100}%`;
      updateScoreDisplay();
      centerCurrentWord();
    }

    function advanceToNextWord() {
      currentWordIndex++;
      currentLetterIndex = 0;
      if (currentWordIndex < foreignWords.length) {
        loadWord(currentWordIndex);
      } else {
        statusMessage.textContent = "🎉 Practice complete!";
        inputField.disabled = true;
      }
      centerCurrentWord();
    }

    function updateScoreDisplay() {
      const total = totalCorrect + totalMistakes;
      const accuracy = total > 0 ? Math.round((totalCorrect / total) * 100) : 100;
      document.getElementById("score-display").textContent =
        `Correct: ${totalCorrect} | Mistakes: ${totalMistakes} | Accuracy: ${accuracy}%`;
    }

    inputField.addEventListener("input", (e) => {
      const wordData = foreignWords[currentWordIndex];
      const currentPhoneme = wordData.phonetic[currentLetterIndex];
      const char = inputField.value.toLowerCase();

      if (!char) return;

      currentInputBuffer += char;
      inputField.value = "";

      if (currentPhoneme === currentInputBuffer) {
        inputHistory.push({ char: currentInputBuffer, status: "correct", scored: true });
        totalCorrect++;
        currentLetterIndex++;
        currentInputBuffer = "";
        highlightCurrentLetter();
        if (currentLetterIndex === wordData.phonetic.length) {
          setTimeout(() => advanceToNextWord(), 0);
        }
      } else if (!currentPhoneme.startsWith(currentInputBuffer)) {
        inputHistory.push({ char: currentInputBuffer, status: "wrong" });
        totalMistakes++;
        currentInputBuffer = "";
      }

      renderInput();
      updateScoreDisplay();
    });

    restartButton.addEventListener("click", () => {
      totalCorrect = 0;
      totalMistakes = 0;
      inputHistory = [];
      currentInputBuffer = "";
      currentWordIndex = 0;
      currentLetterIndex = 0;
      renderAllWords();
      loadWord(0);
      inputField.disabled = false;
    });

    // Init
    renderAllWords();
    loadWord(0);
  </script>
</body>
</html>
