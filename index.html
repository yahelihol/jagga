<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Foreign Language Typing Trainer</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      padding: 2rem;
      background: #f9f9fb;
      color: #222;
      max-width: 900px;
      margin: auto;
    }

    h1 {
      font-size: 2rem;
      margin-bottom: 1rem;
    }

    .stream-wrapper {
      display: flex;
      gap: 2rem;
      overflow-x: auto;
      padding-bottom: 1rem;
      margin-bottom: 1rem;
      border-bottom: 2px solid #ddd;

      /* Add smooth scrolling */
      scroll-behavior: smooth;

      /* Prevent vertical scroll */
      white-space: nowrap;
    }

    /* Container for foreign words & translations */
    .stream-wrapper {
      display: flex;
      gap: 2rem;
      overflow-x: auto;
      padding-bottom: 1rem;
      margin-bottom: 1rem;
      border-bottom: 2px solid #ddd;
    }

    .word-pair {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: max-content;
      opacity: 0;
      transform: translateX(30px);
      transition: all 0.4s ease;
    }

    .word-pair.visible {
      opacity: 1;
      transform: translateX(0);
    }

    .word-block {
      display: flex;
      gap: 0.25rem;
      font-size: 1.8rem;
      line-height: 2.5rem;
    }

    .word-block.translation {
      font-size: 1rem;
      color: #666;
    }

    /* Letter styling */
    .letter {
      padding: 0 0.1rem;
    }

    .current {
      background-color: #ffd54f;
      border-radius: 4px;
    }

    .current-translation {
      font-weight: bold;
      color: #222;
    }

    .score-display {
      font-size: 1rem;
      margin-bottom: 0.5rem;
      color: #333;
    }

    .input-field {
      font-size: 1.5rem;
      padding: 0.75rem;
      background: white;
      border: 1px solid #ccc;
      width: 100%;
      min-height: 2.5rem;
      outline: none;
      margin-bottom: 1rem;
      white-space: nowrap;
      overflow-x: auto;
    }

    .strike {
      text-decoration: line-through;
      color: #e53935;
    }

    .correct {
      color: #43a047;
    }

    .status {
      font-style: italic;
      color: #555;
      margin-bottom: 1rem;
    }

    button {
      background-color: #2196f3;
      color: white;
      border: none;
      padding: 0.6rem 1.2rem;
      font-size: 1rem;
      border-radius: 4px;
      cursor: pointer;
    }

    button:hover {
      background-color: #1976d2;
    }

    /* Slam animation keyframes */
    @keyframes slam {
      0% {
        opacity: 0;
        transform: translateY(-15px) rotate(-20deg) scale(1.3);
      }
      40% {
        opacity: 1;
        transform: translateY(5px) rotate(10deg) scale(0.95);
      }
      70% {
        transform: translateY(-3px) rotate(-5deg) scale(1.05);
      }
      100% {
        opacity: 1;
        transform: translateY(0) rotate(0deg) scale(1);
      }
    }

    /* Apply slam animation to newly typed characters */
    .slam {
      animation: slam 0.1s ease forwards;
      display: inline-block; /* Needed for transform animations */
    }
  </style>
</head>
<body>
  <h1>Foreign Reading Practice</h1>

  <div class="stream-wrapper" id="stream-wrapper"></div>

  <div class="score-display" id="score-display"></div>

  <div class="input-field" id="input-field" contenteditable="true" spellcheck="false"></div>
  <div class="status" id="status-message"></div>
  <div id="progress-bar" style="height: 6px; background: #ddd;">
    <div id="progress-fill" style="height: 100%; width: 0; background: #4caf50;"></div>
  </div>
  <div style="height: 6px;"></div>
  <button id="restart-button"> Restart</button>

  <script>
    const foreignWords = [
      { word: "감사합니다", phonetic: ["gam", "sa", "hab", "ni", "da"], translation: "thank you" },
      { word: "안녕하세요", phonetic: ["an", "nyeong", "ha", "se", "yo"], translation: "hello" },
      { word: "사랑해요", phonetic: ["sa", "rang", "hae", "yo"], translation: "I love you" },
      { word: "미안합니다", phonetic: ["mi", "an", "ham", "ni", "da"], translation: "I'm sorry" },
      { word: "괜찮아요", phonetic: ["gwaen", "chan", "a", "yo"], translation: "It's okay" },
      { word: "네", phonetic: ["ne"], translation: "yes" },
      { word: "아니요", phonetic: ["a", "ni", "yo"], translation: "no" },
      { word: "주세요", phonetic: ["ju", "se", "yo"], translation: "please give me" },
      { word: "이해해요", phonetic: ["i", "hae", "hae", "yo"], translation: "I understand" },
      { word: "몰라요", phonetic: ["mol", "la", "yo"], translation: "I don’t know" }
    ];

    let totalCorrect = 0;
    let totalMistakes = 0;

    let currentWordIndex = 0;
    let currentLetterIndex = 0;
    let inputHistory = [];
    let currentInputBuffer = "";
    const wordSpans = [];

    const streamWrapper = document.getElementById("stream-wrapper");
    const inputField = document.getElementById("input-field");
    const statusMessage = document.getElementById("status-message");
    const progressBar = document.getElementById("progress-fill");
    const restartButton = document.getElementById("restart-button");

    function renderAllWords() {
      streamWrapper.innerHTML = "";
      wordSpans.length = 0;

      foreignWords.forEach(createWordBlock);

      // Reset scroll position to left
      streamWrapper.scrollLeft = 0;
    }

    function centerCurrentWord() {
      const container = document.getElementById("stream-wrapper");
      if (!wordSpans[currentWordIndex]) return;

      const wordPairDiv = container.children[currentWordIndex];
      if (!wordPairDiv) return;

      const containerRect = container.getBoundingClientRect();
      const wordRect = wordPairDiv.getBoundingClientRect();

      // Calculate the scroll offset needed to center the word inside container
      const offset = wordRect.left - containerRect.left - (containerRect.width / 2) + (wordRect.width / 2);

      // Scroll the container smoothly
      container.scrollBy({ left: offset, behavior: "smooth" });
    }

    function createWordBlock(word) {
      const spanGroup = [];

      const wordPair = document.createElement("div");
      wordPair.classList.add("word-pair");

      const wordBlock = document.createElement("div");
      wordBlock.classList.add("word-block");
      wordBlock.title = word.phonetic.join("-");

      [...word.word].forEach(letter => {
        const span = document.createElement("span");
        span.classList.add("letter");
        span.textContent = letter;
        wordBlock.appendChild(span);
        spanGroup.push(span);
      });

      const translation = document.createElement("div");
      translation.textContent = word.translation;
      translation.classList.add("word-block", "translation");

      wordPair.appendChild(wordBlock);
      wordPair.appendChild(translation);

      streamWrapper.appendChild(wordPair);

      setTimeout(() => {
        wordPair.classList.add("visible");
      }, 20);

      wordSpans.push({ foreign: spanGroup, translation });
    }

    function highlightCurrentLetter() {
      wordSpans.forEach((spanGroup, wIndex) => {
        spanGroup.foreign.forEach((span, lIndex) => {
          span.classList.toggle("current", wIndex === currentWordIndex && lIndex === currentLetterIndex);
        });
        spanGroup.translation.classList.toggle("current-translation", wIndex === currentWordIndex);
      });
    }

    function renderInput() {
      inputField.innerHTML = "";

      inputHistory.forEach(entry => {
        const span = document.createElement("span");
        span.textContent = entry.char;
        span.classList.add(entry.status === "correct" ? "correct" : "strike");

        // Add slam animation class to newly typed characters
        // Only if this entry was just added (no 'animated' flag yet)
        if (!entry.animated) {
          span.classList.add("slam");
          entry.animated = true;

          // Remove the animation class after animation ends to allow re-trigger later if needed
          span.addEventListener("animationend", () => {
            span.classList.remove("slam");
          }, { once: true });
        }

        inputField.appendChild(span);
      });

      if (currentInputBuffer) {
        const span = document.createElement("span");
        span.textContent = currentInputBuffer;

        // Animate buffer too as it appears
        span.classList.add("slam");
        span.addEventListener("animationend", () => {
          span.classList.remove("slam");
        }, { once: true });

        inputField.appendChild(span);
      }

      placeCaretAtEnd(inputField);
    }

    function placeCaretAtEnd(el) {
      const range = document.createRange();
      const sel = window.getSelection();
      range.selectNodeContents(el);
      range.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range);
    }

    function loadWord(index) {
      if (index >= foreignWords.length) return;

      currentWordIndex = index;
      currentLetterIndex = 0;
      inputHistory = [];
      currentInputBuffer = "";
      renderInput();
      highlightCurrentLetter();

      inputField.focus();
      statusMessage.textContent = `Word ${index + 1} of ${foreignWords.length}`;
      progressBar.style.width = `${(currentWordIndex / foreignWords.length) * 100}%`;

      updateScoreDisplay();

      centerCurrentWord();
    }

    function advanceToNextWord() {
      currentWordIndex++;
      currentLetterIndex = 0;
      if (currentWordIndex < foreignWords.length) {
        loadWord(currentWordIndex);
      } else {
        statusMessage.textContent = "🎉 Practice complete!";
        inputField.setAttribute("contenteditable", "false");
      }

      // center on current word after advancing
      centerCurrentWord();
    }

    function updateScoreDisplay() {
      const scoreDisplay = document.getElementById("score-display");
      const total = totalCorrect + totalMistakes;
      const accuracy = total > 0 ? Math.round((totalCorrect / total) * 100) : 100;
      scoreDisplay.textContent = `Correct: ${totalCorrect} | Mistakes: ${totalMistakes} | Accuracy: ${accuracy}%`;
    }

    inputField.addEventListener("keydown", (e) => {
      const wordData = foreignWords[currentWordIndex];
      const currentPhoneme = wordData.phonetic[currentLetterIndex];

      if (e.key === "Enter") {
        e.preventDefault();
        return;
      }

      if (e.key === "Backspace") {
        if (currentInputBuffer.length > 0) {
          currentInputBuffer = currentInputBuffer.slice(0, -1);
        } else if (inputHistory.length > 0) {
          const last = inputHistory.pop();
          if (last.status === "correct") {
            currentLetterIndex--;
            highlightCurrentLetter();
            if (last.scored) {
              totalCorrect--;
            }
            updateScoreDisplay();
          }
        }
        renderInput();

        e.preventDefault();
        return;
      }

      if (e.key.length === 1 && /^[a-zA-Z]$/.test(e.key)) {
        currentInputBuffer += e.key.toLowerCase();

        if (currentPhoneme === currentInputBuffer) {
          // ✅ exact match
          inputHistory.push({ char: currentInputBuffer, status: "correct", scored: true });
          totalCorrect++;
          currentLetterIndex++;
          currentInputBuffer = "";
          highlightCurrentLetter();

          if (currentLetterIndex === wordData.phonetic.length) {
            setTimeout(() => advanceToNextWord(), 0);
          }
        } else if (!currentPhoneme.startsWith(currentInputBuffer)) {
          // ❌ not even a prefix
          inputHistory.push({ char: currentInputBuffer, status: "wrong" });
          totalMistakes++;
          currentInputBuffer = "";
        }

        renderInput();
        e.preventDefault();
      }

      updateScoreDisplay();
    });

    restartButton.addEventListener("click", () => {
      totalCorrect = 0;
      totalMistakes = 0;
      inputHistory = [];
      currentInputBuffer = "";
      currentWordIndex = 0;
      currentLetterIndex = 0;

      renderAllWords();
      loadWord(0);
      inputField.setAttribute("contenteditable", "true");
      updateScoreDisplay();
    });

    // Init
    renderAllWords();
    loadWord(0);
  </script>
</body>
</html>
