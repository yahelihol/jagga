<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Foreign Language Typing Trainer with Virtual Keyboard</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      padding: 2rem;
      background: #f9f9fb;
      color: #222;
      max-width: 900px;
      margin: auto;
    }
    h1 {
      font-size: 2rem;
      margin-bottom: 1rem;
    }
    .stream-wrapper {
      display: flex;
      gap: 2rem;
      overflow-x: auto;
      padding-bottom: 1rem;
      margin-bottom: 1rem;
      border-bottom: 2px solid #ddd;
      scroll-behavior: smooth;
      white-space: nowrap;
    }
    .word-pair {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: max-content;
      opacity: 0;
      transform: translateX(30px);
      transition: all 0.4s ease;
    }
    .word-pair.visible {
      opacity: 1;
      transform: translateX(0);
    }
    .word-block {
      display: flex;
      gap: 0.25rem;
      font-size: 1.8rem;
      line-height: 2.5rem;
    }
    .word-block.translation {
      font-size: 1rem;
      color: #666;
    }
    .letter {
      padding: 0 0.1rem;
    }
    .current {
      background-color: #ffd54f;
      border-radius: 4px;
    }
    .current-translation {
      font-weight: bold;
      color: #222;
    }
    .score-display {
      font-size: 1rem;
      margin-bottom: 0.5rem;
      color: #333;
    }
    #input-display {
      font-size: 1.5rem;
      padding: 0.75rem;
      background: white;
      border: 1px solid #ccc;
      width: 100%;
      min-height: 2.5rem;
      margin-bottom: 1rem;
      white-space: nowrap;
      overflow-x: auto;
      user-select: none;
    }
    .strike {
      text-decoration: line-through;
      color: #e53935;
    }
    .correct {
      color: #43a047;
    }
    .status {
      font-style: italic;
      color: #555;
      margin-bottom: 1rem;
    }
    button {
      background-color: #2196f3;
      color: white;
      border: none;
      padding: 0.6rem 1.2rem;
      font-size: 1rem;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
    }
    button:hover {
      background-color: #1976d2;
    }
    @keyframes slam {
      0% {
        opacity: 0;
        transform: translateY(-15px) rotate(-20deg) scale(1.3);
      }
      40% {
        opacity: 1;
        transform: translateY(5px) rotate(10deg) scale(0.95);
      }
      70% {
        transform: translateY(-3px) rotate(-5deg) scale(1.05);
      }
      100% {
        opacity: 1;
        transform: translateY(0) rotate(0deg) scale(1);
      }
    }
    .slam {
      animation: slam 0.3s ease forwards;
      display: inline-block;
    }

  </style>
</head>
<body>
  <h1>Foreign Reading Practice</h1>

  <div class="stream-wrapper" id="stream-wrapper"></div>

  <div class="score-display" id="score-display"></div>

  <!-- Replacing contenteditable input with readonly div for display -->
  <div id="input-display" aria-live="polite" aria-atomic="true" role="textbox" tabindex="0"></div>

  <!-- Virtual keyboard container -->
  <div id="virtual-keyboard" aria-label="Virtual keyboard"></div>

  <div class="status" id="status-message"></div>
  <div id="progress-bar" style="height: 6px; background: #ddd;">
    <div id="progress-fill" style="height: 100%; width: 0; background: #4caf50;"></div>
  </div>
  <div style="height: 6px;"></div>
  <button id="restart-button">Restart</button>

<div id="virtual-keyboard" aria-label="Virtual Keyboard"></div>

<style>
  #virtual-keyboard {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 0.6rem 0.4rem;
  background: #f0f0f3;
  border-top: 1px solid #ccc;
  display: flex;
  flex-direction: column;
  gap: 0.4rem;
  z-index: 999;
  box-shadow: 0 -2px 10px rgba(0,0,0,0.06);
  font-family: "Segoe UI", sans-serif;
}

#virtual-keyboard .key-row {
  display: flex;
  justify-content: center;
  gap: 0.3rem;
}

#virtual-keyboard button {
  flex: 1;
  max-width: 36px;
  height: 48px;
  background: #e0e0e0;
  border: none;
  border-radius: 6px;
  font-size: 1.1rem;
  font-weight: 500;
  color: #222;
  box-shadow: 0 1px 2px rgba(0,0,0,0.15);
  transition: background 0.2s ease;
  cursor: pointer;
  user-select: none;
}

#virtual-keyboard button:active {
  background: #d0d0d0;
}

#virtual-keyboard button.backspace {
  max-width: 80px;
}

@media (min-width: 600px) {
  #virtual-keyboard button {
    max-width: 44px;
    height: 52px;
  }

  #virtual-keyboard button.backspace {
    max-width: 100px;
  }
}

</style>

  <script>
    const foreignWords = [
      { word: "감사합니다", phonetic: ["gam", "sa", "hab", "ni", "da"], translation: "thank you" },
      { word: "안녕하세요", phonetic: ["an", "nyeong", "ha", "se", "yo"], translation: "hello" },
      { word: "사랑해요", phonetic: ["sa", "rang", "hae", "yo"], translation: "I love you" },
      { word: "미안합니다", phonetic: ["mi", "an", "ham", "ni", "da"], translation: "I'm sorry" },
      { word: "괜찮아요", phonetic: ["gwaen", "chan", "a", "yo"], translation: "It's okay" },
      { word: "네", phonetic: ["ne"], translation: "yes" },
      { word: "아니요", phonetic: ["a", "ni", "yo"], translation: "no" },
      { word: "주세요", phonetic: ["ju", "se", "yo"], translation: "please give me" },
      { word: "이해해요", phonetic: ["i", "hae", "hae", "yo"], translation: "I understand" },
      { word: "몰라요", phonetic: ["mol", "la", "yo"], translation: "I don’t know" }
    ];

    let totalCorrect = 0;
    let totalMistakes = 0;

    let currentWordIndex = 0;
    let currentLetterIndex = 0;
    let inputHistory = [];
    let currentInputBuffer = "";
    const wordSpans = [];

    const streamWrapper = document.getElementById("stream-wrapper");
    const inputDisplay = document.getElementById("input-display");
    const statusMessage = document.getElementById("status-message");
    const progressBar = document.getElementById("progress-fill");
    const restartButton = document.getElementById("restart-button");
    const virtualKeyboard = document.getElementById("virtual-keyboard");

    // Create the virtual keyboard keys a-z + Backspace
    function createVirtualKeyboard() {
      // QWERTY layout rows
      const rows = [
        ['q','w','e','r','t','y','u','i','o','p'],
        ['a','s','d','f','g','h','j','k','l'],
        ['z','x','c','v','b','n','m','Backspace']
      ];

      virtualKeyboard.innerHTML = "";

      rows.forEach(row => {
        const rowDiv = document.createElement("div");
        rowDiv.style.display = "flex";
        rowDiv.style.justifyContent = "center";
        rowDiv.style.gap = "0.4rem";
        row.forEach(key => {
          const btn = document.createElement("button");
          btn.textContent = key === "Backspace" ? "⌫" : key;
          btn.setAttribute("data-key", key);
          btn.type = "button";
          if (key === "Backspace") btn.classList.add("wide");
          rowDiv.appendChild(btn);
        });
        virtualKeyboard.appendChild(rowDiv);
      });
    }


    function renderAllWords() {
      streamWrapper.innerHTML = "";
      wordSpans.length = 0;

      foreignWords.forEach(createWordBlock);

      // Reset scroll position to left
      streamWrapper.scrollLeft = 0;
    }

    function centerCurrentWord() {
      const container = streamWrapper;
      if (!wordSpans[currentWordIndex]) return;

      const wordPairDiv = container.children[currentWordIndex];
      if (!wordPairDiv) return;

      const containerRect = container.getBoundingClientRect();
      const wordRect = wordPairDiv.getBoundingClientRect();

      const offset = wordRect.left - containerRect.left - (containerRect.width / 2) + (wordRect.width / 2);

      container.scrollBy({ left: offset, behavior: "smooth" });
    }

    function createWordBlock(word) {
      const spanGroup = [];

      const wordPair = document.createElement("div");
      wordPair.classList.add("word-pair");

      const wordBlock = document.createElement("div");
      wordBlock.classList.add("word-block");
      wordBlock.title = word.phonetic.join("-");

      [...word.word].forEach(letter => {
        const span = document.createElement("span");
        span.classList.add("letter");
        span.textContent = letter;
        wordBlock.appendChild(span);
        spanGroup.push(span);
      });

      const translation = document.createElement("div");
      translation.textContent = word.translation;
      translation.classList.add("word-block", "translation");

      wordPair.appendChild(wordBlock);
      wordPair.appendChild(translation);

      streamWrapper.appendChild(wordPair);

      setTimeout(() => {
        wordPair.classList.add("visible");
      }, 20);

      wordSpans.push({ foreign: spanGroup, translation });
    }

    function highlightCurrentLetter() {
      wordSpans.forEach((spanGroup, wIndex) => {
        spanGroup.foreign.forEach((span, lIndex) => {
          span.classList.toggle("current", wIndex === currentWordIndex && lIndex === currentLetterIndex);
        });
        spanGroup.translation.classList.toggle("current-translation", wIndex === currentWordIndex);
      });
    }

    function renderInput() {
      inputDisplay.innerHTML = "";

      inputHistory.forEach(entry => {
        const span = document.createElement("span");
        span.textContent = entry.char;
        span.classList.add(entry.status === "correct" ? "correct" : "strike");

        if (!entry.animated) {
          span.classList.add("slam");
          entry.animated = true;
          span.addEventListener("animationend", () => {
            span.classList.remove("slam");
          }, { once: true });
        }

        inputDisplay.appendChild(span);
      });

      if (currentInputBuffer) {
        const span = document.createElement("span");
        span.textContent = currentInputBuffer;
        span.classList.add("slam");
        span.addEventListener("animationend", () => {
          span.classList.remove("slam");
        }, { once: true });

        inputDisplay.appendChild(span);
      }
    }

    function loadWord(index) {
      if (index >= foreignWords.length) return;

      currentWordIndex = index;
      currentLetterIndex = 0;
      inputHistory = [];
      currentInputBuffer = "";
      renderInput();
      highlightCurrentLetter();

      statusMessage.textContent = `Word ${index + 1} of ${foreignWords.length}`;
      progressBar.style.width = `${(currentWordIndex / foreignWords.length) * 100}%`;

      updateScoreDisplay();

      centerCurrentWord();
    }

    function advanceToNextWord() {
      currentWordIndex++;
      currentLetterIndex = 0;
      if (currentWordIndex < foreignWords.length) {
        loadWord(currentWordIndex);
      } else {
        statusMessage.textContent = "🎉 Practice complete!";
        // Disable keyboard buttons at end
        virtualKeyboard.querySelectorAll("button").forEach(btn => btn.disabled = true);
      }

      centerCurrentWord();
    }

    function updateScoreDisplay() {
      const scoreDisplay = document.getElementById("score-display");
      const total = totalCorrect + totalMistakes;
      const accuracy = total > 0 ? Math.round((totalCorrect / total) * 100) : 100;
      scoreDisplay.textContent = `Correct: ${totalCorrect} | Mistakes: ${totalMistakes} | Accuracy: ${accuracy}%`;
    }

    // Centralized function to handle input char (from keyboard or virtual keys)
    function handleInputChar(char) {
      const wordData = foreignWords[currentWordIndex];
      const currentPhoneme = wordData.phonetic[currentLetterIndex];

      if (char === "Backspace") {
        if (currentInputBuffer.length > 0) {
          currentInputBuffer = currentInputBuffer.slice(0, -1);
        } else if (inputHistory.length > 0) {
          const last = inputHistory.pop();
          if (last.status === "correct") {
            currentLetterIndex--;
            highlightCurrentLetter();
            if (last.scored) {
              totalCorrect--;
            }
            updateScoreDisplay();
          }
        }
        renderInput();
        return;
      }

      if (/^[a-z]$/.test(char)) {
        currentInputBuffer += char.toLowerCase();

        if (currentPhoneme === currentInputBuffer) {
          inputHistory.push({ char: currentInputBuffer, status: "correct", scored: true });
          totalCorrect++;
          currentLetterIndex++;
          currentInputBuffer = "";
          highlightCurrentLetter();

          if (currentLetterIndex === wordData.phonetic.length) {
            setTimeout(() => advanceToNextWord(), 0);
          }
        } else if (!currentPhoneme.startsWith(currentInputBuffer)) {
          inputHistory.push({ char: currentInputBuffer, status: "wrong" });
          totalMistakes++;
          currentInputBuffer = "";
        }
        renderInput();
      }

      updateScoreDisplay();
    }

    // Physical keyboard input handler
    window.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        return;
      }
      if (e.key === "Backspace") {
        e.preventDefault();
        handleInputChar("Backspace");
        return;
      }
      if (e.key.length === 1 && /^[a-zA-Z]$/.test(e.key)) {
        e.preventDefault();
        handleInputChar(e.key.toLowerCase());
      }
    });

    // Virtual keyboard click handler
    virtualKeyboard.addEventListener("click", (e) => {
      if (e.target.tagName !== "BUTTON") return;
      if (e.target.disabled) return;

      const key = e.target.getAttribute("data-key");
      handleInputChar(key);
    });

    restartButton.addEventListener("click", () => {
      totalCorrect = 0;
      totalMistakes = 0;
      inputHistory = [];
      currentInputBuffer = "";
      currentWordIndex = 0;
      currentLetterIndex = 0;

      renderAllWords();
      loadWord(0);
      // Enable buttons again
      virtualKeyboard.querySelectorAll("button").forEach(btn => btn.disabled = false);
      updateScoreDisplay();
    });

    // Init
    renderAllWords();
    createVirtualKeyboard();
    loadWord(0);
  </script>
</body>
</html>
